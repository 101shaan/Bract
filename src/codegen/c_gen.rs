//! C Code Generator for Prism
//!
//! This module implements the main C code generator that translates
//! Prism AST nodes to equivalent C code. It orchestrates the entire
//! code generation process with performance optimization.

use super::{CodegenContext, CCodeBuilder, CodegenResult, CodegenError, CodegenMetrics};
use crate::ast::*;
use crate::semantic::SymbolTable;
use std::time::Instant;

/// Main C code generator
pub struct CCodeGenerator {
    /// Generation context
    context: CodegenContext,
    /// Code builder
    builder: CCodeBuilder,
    /// Performance metrics
    metrics: CodegenMetrics,
}

impl CCodeGenerator {
    /// Create a new C code generator
    pub fn new(symbol_table: SymbolTable) -> Self {
        Self {
            context: CodegenContext::new(symbol_table),
            builder: CCodeBuilder::with_capacity(8192), // Start with 8KB buffer
            metrics: CodegenMetrics::new(),
        }
    }
    
    /// Generate C code from a Prism module
    pub fn generate_module(&mut self, module: &Module) -> CodegenResult<(String, String)> {
        let start_time = Instant::now();
        
        // Generate header includes
        self.generate_includes()?;
        
        // Generate forward declarations
        self.generate_forward_declarations(module)?;
        
        // Generate all items
        for item in &module.items {
            self.generate_item(item)?;
        }
        
        // Record performance metrics
        self.metrics.compilation_time_ms = start_time.elapsed().as_millis();
        self.metrics.memory_usage_bytes = self.estimate_memory_usage();
        
        Ok(self.builder.clone().build())
    }
    
    /// Generate includes section
    fn generate_includes(&mut self) -> CodegenResult<()> {
        self.builder.header_context();
        self.builder.comment("Generated by Prism Compiler");
        self.builder.comment("https://github.com/prism-lang/prism");
        self.builder.newline();
        
        // Add all required includes
        for include in &self.context.includes {
            self.builder.line(include);
        }
        self.builder.newline();
        
        self.builder.code_context();
        Ok(())
    }
    
    /// Generate forward declarations
    fn generate_forward_declarations(&mut self, module: &Module) -> CodegenResult<()> {
        self.builder.header_context();
        self.builder.comment("Forward declarations");
        
        // First pass: collect all type and function declarations
        for item in &module.items {
            match item {
                Item::Function { .. } => {
                    // Function forward declarations will be generated during function processing
                },
                Item::Struct { name, .. } => {
                    let struct_name = self.format_identifier(name);
                    self.builder.line(&format!("typedef struct {} {};", struct_name, struct_name));
                },
                Item::Enum { name, .. } => {
                    let enum_name = self.format_identifier(name);
                    self.builder.line(&format!("typedef enum {} {};", enum_name, enum_name));
                },
                _ => {}
            }
        }
        
        self.builder.newline();
        self.builder.code_context();
        Ok(())
    }
    
    /// Generate code for an item
    fn generate_item(&mut self, item: &Item) -> CodegenResult<()> {
        self.metrics.record_node();
        
        match item {
            Item::Function { .. } => {
                self.generate_function(item)?;
            },
            Item::Struct { .. } => {
                self.generate_struct(item)?;
            },
            Item::Enum { .. } => {
                self.generate_enum(item)?;
            },
            Item::Const { .. } => {
                self.generate_const(item)?;
            },
            Item::Module { .. } => {
                // Nested modules are handled recursively
                self.generate_nested_module(item)?;
            },
            Item::Impl { .. } => {
                self.generate_impl(item)?;
            },
            _ => {
                return Err(CodegenError::UnsupportedFeature(
                    format!("Item type not yet supported: {:?}", item)
                ));
            }
        }
        
        Ok(())
    }
    
    /// Generate a function
    fn generate_function(&mut self, item: &Item) -> CodegenResult<()> {
        if let Item::Function { name, params, return_type, body, .. } = item {
            let func_name = self.format_identifier(name);
            
            // Generate function signature
            let mut signature = String::new();
            
            // Return type
            let ret_type = if let Some(ret_type) = return_type {
                self.generate_type_name(ret_type)?
            } else {
                "void".to_string()
            };
            signature.push_str(&ret_type);
            signature.push(' ');
            signature.push_str(&func_name);
            signature.push('(');
            
            // Parameters
            if params.is_empty() {
                signature.push_str("void");
            } else {
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        signature.push_str(", ");
                    }
                    
                    let param_type = if let Some(type_ann) = &param.type_annotation {
                        self.generate_type_name(type_ann)?
                    } else {
                        return Err(CodegenError::TypeConversion(
                            "Function parameter must have explicit type".to_string()
                        ));
                    };
                    
                    let param_name = self.generate_parameter_name(&param.pattern)?;
                    signature.push_str(&format!("{} {}", param_type, param_name));
                }
            }
            signature.push(')');
            
            // Generate function body
            self.context.current_function = Some(func_name.clone());
            self.context.enter_scope();
            
            if let Some(body_expr) = body {
                // Generate function signature and opening
                self.builder.line(&format!("{} {{", signature));
                self.builder.indent_inc();
                
                // Generate function body
                if let Err(e) = Self::generate_function_body_impl(body_expr, &mut self.context, &mut self.builder) {
                    eprintln!("Error generating function body: {}", e);
                    return Err(e);
                }
                
                // Close function
                self.builder.indent_dec();
                self.builder.line("}");
                self.builder.newline();
            } else {
                // External function declaration
                self.builder.header_context();
                self.builder.line(&format!("{};", signature));
                self.builder.code_context();
            }
            
            self.context.exit_scope();
            self.context.current_function = None;
            
            self.metrics.record_lines(10); // Estimate lines generated
        }
        
        Ok(())
    }
    
    /// Generate function body (static method to avoid borrowing conflicts)
    fn generate_function_body_impl(
        body: &Expr,
        context: &mut CodegenContext,
        builder: &mut CCodeBuilder
    ) -> CodegenResult<()> {
        use super::statements::StatementGenerator;
        use super::expressions::ExpressionGenerator;
        
        match body {
            Expr::Block { statements, trailing_expr, .. } => {
                // Generate statements
                let mut stmt_gen = StatementGenerator::new();
                for stmt in statements {
                    stmt_gen.generate_statement(stmt, context, builder)?;
                }
                
                // Generate trailing expression as return
                if let Some(expr) = trailing_expr {
                    let mut expr_gen = ExpressionGenerator::new(context);
                    let expr_code = expr_gen.generate_expression(expr)?;
                    builder.line(&format!("return {};", expr_code));
                }
            },
            _ => {
                // Single expression body
                let mut expr_gen = ExpressionGenerator::new(context);
                let expr_code = expr_gen.generate_expression(body)?;
                builder.line(&format!("return {};", expr_code));
            }
        }
        
        Ok(())
    }

    /// Generate function body (legacy method for compatibility)
    #[allow(dead_code)]
    fn generate_function_body(&mut self, body: &Expr, builder: &mut CCodeBuilder) -> CodegenResult<()> {
        Self::generate_function_body_impl(body, &mut self.context, builder)
    }
    
    /// Generate a struct definition
    fn generate_struct(&mut self, item: &Item) -> CodegenResult<()> {
        if let Item::Struct { name, fields, .. } = item {
            let struct_name = self.format_identifier(name);
            
            self.builder.header_context();
            self.builder.line(&format!("struct {} {{", struct_name));
            self.builder.indent_inc();
            
            match fields {
                StructFields::Named(field_list) => {
                    for field in field_list {
                        let field_type = self.generate_type_name(&field.field_type)?;
                        let field_name = self.format_identifier(&field.name);
                        self.builder.line(&format!("{} {};", field_type, field_name));
                    }
                },
                StructFields::Tuple(types) => {
                    for (i, field_type) in types.iter().enumerate() {
                        let field_type_name = self.generate_type_name(field_type)?;
                        self.builder.line(&format!("{} field_{};", field_type_name, i));
                    }
                },
                StructFields::Unit => {
                    self.builder.line("char _unit_field; // Unit struct placeholder");
                }
            }
            
            self.builder.indent_dec();
            self.builder.line("};");
            self.builder.newline();
            self.builder.code_context();
            
            self.metrics.record_lines(5);
        }
        
        Ok(())
    }
    
    /// Generate an enum definition
    fn generate_enum(&mut self, item: &Item) -> CodegenResult<()> {
        if let Item::Enum { name, variants, .. } = item {
            let enum_name = self.format_identifier(name);
            
            self.builder.header_context();
            
            // Generate enum tag
            self.builder.line(&format!("typedef enum {}_Tag {{", enum_name));
            self.builder.indent_inc();
            
            for (i, variant) in variants.iter().enumerate() {
                let variant_name = self.format_identifier(&variant.name);
                let tag_name = format!("{}_{}", enum_name, variant_name);
                
                if i == variants.len() - 1 {
                    self.builder.line(&format!("{}", tag_name));
                } else {
                    self.builder.line(&format!("{},", tag_name));
                }
            }
            
            self.builder.indent_dec();
            self.builder.line(&format!("}} {}_Tag;", enum_name));
            self.builder.newline();
            
            // Generate enum struct (tagged union)
            self.builder.line(&format!("typedef struct {} {{", enum_name));
            self.builder.indent_inc();
            self.builder.line(&format!("{}_Tag tag;", enum_name));
            self.builder.line("union {");
            self.builder.indent_inc();
            
            for variant in variants {
                let variant_name = self.format_identifier(&variant.name);
                
                match &variant.fields {
                    StructFields::Named(field_list) => {
                        self.builder.line(&format!("struct {{"));
                        self.builder.indent_inc();
                        for field in field_list {
                            let field_type = self.generate_type_name(&field.field_type)?;
                            let field_name = self.format_identifier(&field.name);
                            self.builder.line(&format!("{} {};", field_type, field_name));
                        }
                        self.builder.indent_dec();
                        self.builder.line(&format!("}} {};", variant_name));
                    },
                    StructFields::Tuple(types) => {
                        self.builder.line(&format!("struct {{"));
                        self.builder.indent_inc();
                        for (i, field_type) in types.iter().enumerate() {
                            let field_type_name = self.generate_type_name(field_type)?;
                            self.builder.line(&format!("{} field_{};", field_type_name, i));
                        }
                        self.builder.indent_dec();
                        self.builder.line(&format!("}} {};", variant_name));
                    },
                    StructFields::Unit => {
                        // Unit variants don't need data
                    }
                }
            }
            
            self.builder.indent_dec();
            self.builder.line("} data;");
            self.builder.indent_dec();
            self.builder.line(&format!("}} {};", enum_name));
            self.builder.newline();
            self.builder.code_context();
            
            self.metrics.record_lines(15);
        }
        
        Ok(())
    }
    
    /// Generate a constant definition
    fn generate_const(&mut self, item: &Item) -> CodegenResult<()> {
        if let Item::Const { name, type_annotation, value, .. } = item {
            let const_name = self.format_identifier(name);
            let const_type = self.generate_type_name(type_annotation)?;
            let const_value = self.generate_expression(value)?;
            
            self.builder.header_context();
            self.builder.line(&format!("extern const {} {};", const_type, const_name));
            self.builder.code_context();
            
            self.builder.line(&format!("const {} {} = {};", const_type, const_name, const_value));
            self.builder.newline();
            
            self.metrics.record_lines(2);
        }
        
        Ok(())
    }
    
    /// Generate a nested module (placeholder)
    fn generate_nested_module(&mut self, item: &Item) -> CodegenResult<()> {
        // For now, flatten nested modules
        if let Item::Module { items: Some(module_items), .. } = item {
            for item in module_items {
                self.generate_item(item)?;
            }
        }
        
        Ok(())
    }
    
    /// Generate an impl block
    fn generate_impl(&mut self, item: &Item) -> CodegenResult<()> {
        if let Item::Impl { target_type, items, .. } = item {
            // Get the struct name for method name prefixing
            let struct_name = match target_type {
                Type::Path { segments, .. } => {
                    segments.iter()
                        .map(|s| self.format_identifier(s))
                        .collect::<Vec<_>>()
                        .join("_")
                },
                _ => {
                    return Err(CodegenError::UnsupportedFeature(
                        "Impl blocks only supported for named types".to_string()
                    ));
                }
            };
            
            // Generate forward declarations for all methods
            self.builder.header_context();
            self.builder.comment(&format!("Methods for {}", struct_name));
            
            // Generate each impl item
            for impl_item in items {
                match impl_item {
                    ImplItem::Function { name, params, return_type, body, .. } => {
                        self.generate_impl_method(&struct_name, name, params, return_type, body)?;
                    },
                    ImplItem::Const { name, type_annotation, value, .. } => {
                        self.generate_impl_const(&struct_name, name, type_annotation, value)?;
                    },
                    ImplItem::Type { .. } => {
                        // Associated types are not directly supported in C
                        return Err(CodegenError::UnsupportedFeature(
                            "Associated types not supported in C generation".to_string()
                        ));
                    }
                }
            }
            
            self.builder.newline();
            self.builder.code_context();
            self.metrics.record_lines(items.len() * 5); // Estimate
        }
        
        Ok(())
    }
    
    /// Generate an impl method
    fn generate_impl_method(
        &mut self,
        struct_name: &str,
        method_name: &InternedString,
        params: &[Parameter],
        return_type: &Option<Type>,
        body: &Option<Expr>
    ) -> CodegenResult<()> {
        let method_name_str = self.format_identifier(method_name);
        let full_method_name = format!("{}_{}", struct_name, method_name_str);
        
        // Generate method signature
        let mut signature = String::new();
        
        // Return type
        let ret_type = if let Some(ret_type) = return_type {
            self.generate_type_name(ret_type)?
        } else {
            "void".to_string()
        };
        signature.push_str(&ret_type);
        signature.push(' ');
        signature.push_str(&full_method_name);
        signature.push('(');
        
        // Parameters (first parameter is always the struct instance)
        if params.is_empty() {
            signature.push_str("void");
        } else {
            for (i, param) in params.iter().enumerate() {
                if i > 0 {
                    signature.push_str(", ");
                }
                
                let param_type = if let Some(type_ann) = &param.type_annotation {
                    self.generate_type_name(type_ann)?
                } else {
                    return Err(CodegenError::TypeConversion(
                        "Method parameter must have explicit type".to_string()
                    ));
                };
                
                let param_name = self.generate_parameter_name(&param.pattern)?;
                signature.push_str(&format!("{} {}", param_type, param_name));
            }
        }
        signature.push(')');
        
        // Generate method body
        if let Some(body_expr) = body {
            // Generate method signature and opening
            self.builder.line(&format!("{} {{", signature));
            self.builder.indent_inc();
            
            // Generate method body
            self.context.current_function = Some(full_method_name.clone());
            self.context.enter_scope();
            
            if let Err(e) = Self::generate_function_body_impl(body_expr, &mut self.context, &mut self.builder) {
                eprintln!("Error generating method body: {}", e);
                return Err(e);
            }
            
            self.context.exit_scope();
            self.context.current_function = None;
            
            // Close method
            self.builder.indent_dec();
            self.builder.line("}");
            self.builder.newline();
        } else {
            // Method declaration only
            self.builder.header_context();
            self.builder.line(&format!("{};", signature));
            self.builder.code_context();
        }
        
        Ok(())
    }
    
    /// Generate an impl constant
    fn generate_impl_const(
        &mut self,
        struct_name: &str,
        const_name: &InternedString,
        type_annotation: &Type,
        value: &Option<Expr>
    ) -> CodegenResult<()> {
        let const_name_str = self.format_identifier(const_name);
        let full_const_name = format!("{}_{}", struct_name, const_name_str);
        let type_name = self.generate_type_name(type_annotation)?;
        
        if let Some(value_expr) = value {
            let value_code = self.generate_expression(value_expr)?;
            self.builder.header_context();
            self.builder.line(&format!("static const {} {} = {};", type_name, full_const_name, value_code));
            self.builder.code_context();
        } else {
            // Declaration only
            self.builder.header_context();
            self.builder.line(&format!("extern const {} {};", type_name, full_const_name));
            self.builder.code_context();
        }
        
        Ok(())
    }
    
    /// Generate code for a statement (placeholder)
    #[allow(dead_code)]
    fn generate_statement(&mut self, _stmt: &Stmt, _builder: &mut CCodeBuilder) -> CodegenResult<()> {
        // This will be implemented in statements.rs
        _builder.comment("Statement generation not yet implemented");
        Ok(())
    }
    
    /// Generate code for an expression (placeholder)
    fn generate_expression(&mut self, expr: &Expr) -> CodegenResult<String> {
        // This will be implemented in expressions.rs
        match expr {
            Expr::Literal { literal, .. } => {
                match literal {
                    Literal::Integer { value, .. } => Ok(value.clone()),
                    Literal::Float { value, .. } => Ok(value.clone()),
                    Literal::String { .. } => Ok("\"placeholder\"".to_string()),
                    Literal::Bool(b) => Ok(if *b { "true" } else { "false" }.to_string()),
                    Literal::Null => Ok("NULL".to_string()),
                    _ => Ok("0".to_string()),
                }
            },
            Expr::Identifier { name, .. } => {
                Ok(self.format_identifier(name))
            },
            _ => Ok("/* expression placeholder */".to_string()),
        }
    }
    
    /// Generate type name in C
    fn generate_type_name(&self, ty: &Type) -> CodegenResult<String> {
        match ty {
            Type::Primitive { kind, .. } => {
                let type_name = match kind {
                    PrimitiveType::I8 => "int8_t",
                    PrimitiveType::I16 => "int16_t",
                    PrimitiveType::I32 => "int32_t",
                    PrimitiveType::I64 => "int64_t",
                    PrimitiveType::I128 => "int128_t",
                    PrimitiveType::ISize => "intptr_t",
                    PrimitiveType::U8 => "uint8_t",
                    PrimitiveType::U16 => "uint16_t",
                    PrimitiveType::U32 => "uint32_t",
                    PrimitiveType::U64 => "uint64_t",
                    PrimitiveType::U128 => "uint128_t",
                    PrimitiveType::USize => "uintptr_t",
                    PrimitiveType::F32 => "float",
                    PrimitiveType::F64 => "double",
                    PrimitiveType::Bool => "bool",
                    PrimitiveType::Char => "char32_t",
                    PrimitiveType::Str => "prism_str_t",
                    PrimitiveType::Unit => "void",
                };
                Ok(type_name.to_string())
            },
            Type::Path { segments, .. } => {
                // User-defined type
                let type_name = segments.iter()
                    .map(|s| self.format_identifier(s))
                    .collect::<Vec<_>>()
                    .join("_");
                Ok(format!("struct {}", type_name))
            },
            Type::Reference { target_type, .. } => {
                let target = self.generate_type_name(target_type)?;
                Ok(format!("{}*", target))
            },
            Type::Array { element_type, .. } => {
                let element = self.generate_type_name(element_type)?;
                Ok(format!("{}*", element)) // Arrays as pointers for now
            },
            _ => {
                Err(CodegenError::UnsupportedFeature(
                    format!("Type not yet supported: {:?}", ty)
                ))
            }
        }
    }
    
    /// Generate parameter name from pattern
    fn generate_parameter_name(&self, pattern: &Pattern) -> CodegenResult<String> {
        match pattern {
            Pattern::Identifier { name, .. } => {
                Ok(self.format_identifier(name))
            },
            _ => {
                Err(CodegenError::UnsupportedFeature(
                    "Complex parameter patterns not yet supported".to_string()
                ))
            }
        }
    }
    
    /// Format identifier for C
    fn format_identifier(&self, name: &InternedString) -> String {
        // For now, just use the ID as the identifier
        // In a real implementation, this would look up the actual string
        format!("id_{}", name.id)
    }
    
    /// Estimate memory usage
    fn estimate_memory_usage(&self) -> usize {
        self.builder.code().len() + self.builder.header().len() + 
        std::mem::size_of::<CodegenContext>() + std::mem::size_of::<CCodeBuilder>()
    }
    
    /// Get performance metrics
    pub fn metrics(&self) -> &CodegenMetrics {
        &self.metrics
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::semantic::SymbolTable;
    use crate::lexer::Position;
    
    fn dummy_span() -> Span {
        Span::single(Position::new(1, 1, 0, 0))
    }
    
    #[test]
    fn test_c_generator_creation() {
        let symbol_table = SymbolTable::new();
        let generator = CCodeGenerator::new(symbol_table);
        
        assert_eq!(generator.context.scope_depth, 0);
        assert_eq!(generator.metrics.nodes_processed, 0);
    }
    
    #[test]
    fn test_simple_function_generation() {
        let symbol_table = SymbolTable::new();
        let mut generator = CCodeGenerator::new(symbol_table);
        
        let function = Item::Function {
            visibility: Visibility::Public,
            name: InternedString::new(1),
            generics: Vec::new(),
            params: Vec::new(),
            return_type: Some(Type::Primitive {
                kind: PrimitiveType::I32,
                span: dummy_span(),
            }),
            body: Some(Expr::Literal {
                literal: Literal::Integer {
                    value: "42".to_string(),
                    base: crate::lexer::token::NumberBase::Decimal,
                    suffix: None,
                },
                span: dummy_span(),
            }),
            is_extern: false,
            span: dummy_span(),
        };
        
        assert!(generator.generate_function(&function).is_ok());
        assert!(generator.metrics.nodes_processed > 0);
    }
    
    #[test]
    fn test_struct_generation() {
        let symbol_table = SymbolTable::new();
        let mut generator = CCodeGenerator::new(symbol_table);
        
        let struct_item = Item::Struct {
            visibility: Visibility::Public,
            name: InternedString::new(2),
            generics: Vec::new(),
            fields: StructFields::Named(vec![
                StructField {
                    visibility: Visibility::Public,
                    name: InternedString::new(3),
                    field_type: Type::Primitive {
                        kind: PrimitiveType::I32,
                        span: dummy_span(),
                    },
                    span: dummy_span(),
                }
            ]),
            span: dummy_span(),
        };
        
        assert!(generator.generate_struct(&struct_item).is_ok());
        assert!(generator.builder.header().contains("struct"));
    }
    
    #[test]
    fn test_type_name_generation() {
        let symbol_table = SymbolTable::new();
        let generator = CCodeGenerator::new(symbol_table);
        
        let int_type = Type::Primitive {
            kind: PrimitiveType::I32,
            span: dummy_span(),
        };
        
        assert_eq!(generator.generate_type_name(&int_type).unwrap(), "int32_t");
        
        let float_type = Type::Primitive {
            kind: PrimitiveType::F64,
            span: dummy_span(),
        };
        
        assert_eq!(generator.generate_type_name(&float_type).unwrap(), "double");
    }
    
    #[test]
    fn test_impl_block_generation() {
        let symbol_table = SymbolTable::new();
        let mut generator = CCodeGenerator::new(symbol_table);
        
        // Create an impl block for a struct
        let impl_block = Item::Impl {
            generics: Vec::new(),
            target_type: Type::Path {
                segments: vec![InternedString::new(10)], // "MyStruct"
                generics: Vec::new(),
                span: dummy_span(),
            },
            trait_ref: None,
            items: vec![
                ImplItem::Function {
                    visibility: Visibility::Public,
                    name: InternedString::new(11), // "new"
                    generics: Vec::new(),
                    params: vec![],
                    return_type: Some(Type::Path {
                        segments: vec![InternedString::new(10)],
                        generics: Vec::new(),
                        span: dummy_span(),
                    }),
                    body: Some(Expr::Literal {
                        literal: Literal::Integer {
                            value: "0".to_string(),
                            base: crate::lexer::token::NumberBase::Decimal,
                            suffix: None,
                        },
                        span: dummy_span(),
                    }),
                    span: dummy_span(),
                },
                ImplItem::Const {
                    visibility: Visibility::Public,
                    name: InternedString::new(12), // "DEFAULT_VALUE"
                    type_annotation: Type::Primitive {
                        kind: PrimitiveType::I32,
                        span: dummy_span(),
                    },
                    value: Some(Expr::Literal {
                        literal: Literal::Integer {
                            value: "42".to_string(),
                            base: crate::lexer::token::NumberBase::Decimal,
                            suffix: None,
                        },
                        span: dummy_span(),
                    }),
                    span: dummy_span(),
                },
            ],
            span: dummy_span(),
        };
        
        // Test impl block generation
        assert!(generator.generate_impl(&impl_block).is_ok());
        
        // Verify that the generated code contains method names
        let header = generator.builder.header();
        assert!(header.contains("Methods for id_10"));
        assert!(header.contains("id_10_id_11")); // MyStruct_new
        assert!(header.contains("id_10_id_12")); // MyStruct_DEFAULT_VALUE
    }
} 