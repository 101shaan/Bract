//! Example program compilation tests
//! 
//! These tests compile the example Prism programs in the examples/ directory
//! to ensure they work correctly with the compiler.

use prism::{Parser, semantic::SemanticAnalyzer, codegen::CCodeGenerator};
use std::fs;
use std::path::Path;

/// Test helper to run the complete compilation pipeline
fn compile_prism_source(source: &str) -> Result<(String, String), String> {
    // Parse
    let mut parser = Parser::new(source, 0)
        .map_err(|e| format!("Parser creation failed: {}", e))?;
    let ast = parser.parse_module()
        .map_err(|e| format!("Parsing failed: {}", e))?;
    
    // Semantic analysis
    let mut analyzer = SemanticAnalyzer::new();
    let analysis_result = analyzer.analyze(&ast);
    
    if !analysis_result.errors.is_empty() {
        return Err(format!("Semantic analysis failed: {:?}", analysis_result.errors));
    }
    
    // Code generation
    let mut generator = CCodeGenerator::new(analysis_result.symbol_table);
    let (header, implementation) = generator.generate_module(&ast)
        .map_err(|e| format!("Code generation failed: {}", e))?;
    
    Ok((header, implementation))
}

/// Test the hello_world.prism example
#[test]
fn test_hello_world_example() {
    let example_path = Path::new("examples/hello_world.prism");
    
    if !example_path.exists() {
        println!("Skipping hello_world example test - file not found");
        return;
    }
    
    let source = fs::read_to_string(example_path)
        .expect("Should be able to read hello_world.prism");
    
    let result = compile_prism_source(&source);
    assert!(result.is_ok(), "hello_world.prism should compile successfully");
    
    let (header, implementation) = result.unwrap();
    
    // Basic validation
    assert!(header.contains("// Generated by Prism Compiler"));
    assert!(implementation.contains("// Generated by Prism Compiler"));
    assert!(implementation.contains("main") || header.contains("main"));
}

/// Test the simple_function.prism example
#[test]
fn test_simple_function_example() {
    let example_path = Path::new("examples/simple_function.prism");
    
    if !example_path.exists() {
        println!("Skipping simple_function example test - file not found");
        return;
    }
    
    let source = fs::read_to_string(example_path)
        .expect("Should be able to read simple_function.prism");
    
    let result = compile_prism_source(&source);
    assert!(result.is_ok(), "simple_function.prism should compile successfully");
    
    let (header, implementation) = result.unwrap();
    
    // Basic validation
    assert!(header.contains("// Generated by Prism Compiler"));
    assert!(implementation.contains("// Generated by Prism Compiler"));
}

/// Test compilation of a canonical Prism program
#[test]
fn test_canonical_fibonacci() {
    let source = r#"
        // Recursive Fibonacci implementation
        fn fibonacci(n: i32) -> i32 {
            if n <= 1 {
                return n;
            }
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
        
        fn main() -> i32 {
            let result = fibonacci(10);
            return result;
        }
    "#;
    
    let result = compile_prism_source(source);
    assert!(result.is_ok(), "Fibonacci example should compile successfully");
    
    let (_header, implementation) = result.unwrap();
    
    // Verify expected content
    assert!(implementation.contains("fibonacci"));
    assert!(implementation.contains("main"));
    assert!(implementation.contains("if") || implementation.contains("recursive"));
}

/// Test compilation of a data structures example
#[test]
fn test_canonical_data_structures() {
    let source = r#"
        struct Point {
            x: f64,
            y: f64,
        }
        
        struct Rectangle {
            top_left: Point,
            bottom_right: Point,
        }
        
        fn area(rect: Rectangle) -> f64 {
            let width = rect.bottom_right.x - rect.top_left.x;
            let height = rect.bottom_right.y - rect.top_left.y;
            return width * height;
        }
        
        fn main() -> i32 {
            let point1 = Point { x: 0.0, y: 0.0 };
            let point2 = Point { x: 10.0, y: 5.0 };
            let rect = Rectangle { top_left: point1, bottom_right: point2 };
            let area_value = area(rect);
            return 0;
        }
    "#;
    
    let result = compile_prism_source(source);
    assert!(result.is_ok(), "Data structures example should compile successfully");
    
    let (_header, implementation) = result.unwrap();
    
    // Verify struct definitions
    assert!(_header.contains("Point") || implementation.contains("Point"));
    assert!(_header.contains("Rectangle") || implementation.contains("Rectangle"));
    assert!(implementation.contains("area"));
    assert!(implementation.contains("main"));
}

/// Test compilation of an enum example
#[test]
fn test_canonical_enums() {
    let source = r#"
        enum Status {
            Success,
            Error(i32),
            Warning { code: i32, message: String },
        }
        
        fn handle_status(status: Status) -> i32 {
            match status {
                Status::Success => 0,
                Status::Error(code) => code,
                Status::Warning { code, message } => code,
            }
        }
        
        fn main() -> i32 {
            let status = Status::Success;
            return handle_status(status);
        }
    "#;
    
    let result = compile_prism_source(source);
    
    // This might not be fully implemented yet
    match result {
        Ok((_header, implementation)) => {
            assert!(_header.contains("Status") || implementation.contains("Status"));
            assert!(implementation.contains("handle_status"));
            assert!(implementation.contains("main"));
        }
        Err(_) => {
            println!("Enum example not yet fully supported - this is expected");
        }
    }
}

/// Test compilation of a control flow example
#[test]
fn test_canonical_control_flow() {
    let source = r#"
        fn factorial_iterative(n: i32) -> i32 {
            let mut result = 1;
            let mut i = 1;
            
            while i <= n {
                result = result * i;
                i = i + 1;
            }
            
            return result;
        }
        
        fn factorial_recursive(n: i32) -> i32 {
            if n <= 1 {
                return 1;
            }
            return n * factorial_recursive(n - 1);
        }
        
        fn test_control_flow() -> i32 {
            let n = 5;
            let iter_result = factorial_iterative(n);
            let rec_result = factorial_recursive(n);
            
            if iter_result == rec_result {
                return 1; // Success
            } else {
                return 0; // Failure
            }
        }
        
        fn main() -> i32 {
            return test_control_flow();
        }
    "#;
    
    let result = compile_prism_source(source);
    assert!(result.is_ok(), "Control flow example should compile successfully");
    
    let (_header, implementation) = result.unwrap();
    
    // Verify functions are present
    assert!(implementation.contains("factorial_iterative"));
    assert!(implementation.contains("factorial_recursive"));
    assert!(implementation.contains("test_control_flow"));
    assert!(implementation.contains("main"));
}

/// Test compilation of array and collection usage
#[test]
fn test_canonical_arrays() {
    let source = r#"
        fn sum_array(arr: [i32; 5]) -> i32 {
            let mut sum = 0;
            let mut i = 0;
            
            while i < 5 {
                sum = sum + arr[i];
                i = i + 1;
            }
            
            return sum;
        }
        
        fn main() -> i32 {
            let numbers = [1, 2, 3, 4, 5];
            let total = sum_array(numbers);
            return total;
        }
    "#;
    
    let result = compile_prism_source(source);
    
    // Arrays might not be fully implemented yet
    match result {
        Ok((_header, implementation)) => {
            assert!(implementation.contains("sum_array"));
            assert!(implementation.contains("main"));
        }
        Err(_) => {
            println!("Array example not yet fully supported - this is expected");
        }
    }
}

/// Test all example files in the examples/ directory
#[test]
fn test_all_example_files() {
    let examples_dir = Path::new("examples");
    
    if !examples_dir.exists() {
        println!("Examples directory not found - skipping");
        return;
    }
    
    let entries = fs::read_dir(examples_dir)
        .expect("Should be able to read examples directory");
    
    let mut example_count = 0;
    let mut success_count = 0;
    
    for entry in entries {
        let entry = entry.expect("Should be able to read directory entry");
        let path = entry.path();
        
        if path.extension().and_then(|s| s.to_str()) == Some("prism") {
            example_count += 1;
            let filename = path.file_name().unwrap().to_str().unwrap();
            
            println!("Testing example: {}", filename);
            
            let source = match fs::read_to_string(&path) {
                Ok(content) => content,
                Err(e) => {
                    println!("Failed to read {}: {}", filename, e);
                    continue;
                }
            };
            
            match compile_prism_source(&source) {
                Ok((header, implementation)) => {
                    // Basic validation
                    assert!(header.contains("// Generated by Prism Compiler"));
                    assert!(implementation.contains("// Generated by Prism Compiler"));
                    success_count += 1;
                    println!("✅ {} compiled successfully", filename);
                }
                Err(e) => {
                    println!("❌ {} failed to compile: {}", filename, e);
                    // Don't fail the test - some examples might use unimplemented features
                }
            }
        }
    }
    
    println!("Compiled {}/{} example files successfully", success_count, example_count);
    
    // At least some examples should work
    if example_count > 0 {
        assert!(success_count > 0, "At least one example should compile successfully");
    }
}

/// Test performance with multiple example compilations
#[test]
fn test_examples_performance() {
    use std::time::Instant;
    
    let examples = vec![
        r#"fn main() -> i32 { return 42; }"#,
        r#"fn double(x: i32) -> i32 { return x * 2; } fn main() -> i32 { return double(21); }"#,
        r#"fn factorial(n: i32) -> i32 { if n <= 1 { return 1; } return n * factorial(n - 1); } fn main() -> i32 { return factorial(5); }"#,
    ];
    
    let start = Instant::now();
    
    for (i, source) in examples.iter().enumerate() {
        let result = compile_prism_source(source);
        assert!(result.is_ok(), "Example {} should compile successfully", i);
    }
    
    let elapsed = start.elapsed();
    
    println!("Compiled {} examples in {:?}", examples.len(), elapsed);
    println!("Average time per example: {:?}", elapsed / examples.len() as u32);
    
    // Performance assertion
    let avg_ms = elapsed.as_millis() / examples.len() as u128;
    assert!(avg_ms < 100, "Average compilation time too slow: {}ms", avg_ms);
} 