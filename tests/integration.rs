//! End-to-end integration tests
//! 
//! These tests validate the complete compiler pipeline from source code to C code generation.

use bract::{Parser, semantic::SemanticAnalyzer, codegen::{CCodeGenerator, runtime::RuntimeGenerator}};
use std::process::Command;
use std::fs;
use std::path::Path;
use tempfile::TempDir;

/// Test helper to create a temporary directory
fn create_temp_dir() -> TempDir {
    TempDir::new().expect("Failed to create temp directory")
}

/// Test helper to write a test file
fn write_test_file(dir: &Path, filename: &str, content: &str) -> std::path::PathBuf {
    let file_path = dir.join(filename);
    fs::write(&file_path, content).expect("Failed to write test file");
    file_path
}

/// Test helper to run the complete compilation pipeline
fn compile_bract_source(source: &str) -> Result<(String, String), String> {
    // Parse
    let mut parser = Parser::new(source, 0)
        .map_err(|e| format!("Parser creation failed: {}", e))?;
    let ast = parser.parse_module()
        .map_err(|e| format!("Parsing failed: {}", e))?;
    
    // Semantic analysis
    let mut analyzer = SemanticAnalyzer::new();
    let analysis_result = analyzer.analyze(&ast);
    
    if !analysis_result.errors.is_empty() {
        return Err(format!("Semantic analysis failed: {:?}", analysis_result.errors));
    }
    
    // Code generation
    let mut generator = CCodeGenerator::new(analysis_result.symbol_table);
    let (header, implementation) = generator.generate_module(&ast)
        .map_err(|e| format!("Code generation failed: {}", e))?;
    
    Ok((header, implementation))
}

/// Test helper to validate generated C code structure
fn validate_c_code(header: &str, implementation: &str) {
    // Basic validation that the generated C code has expected structure
    assert!(header.contains("// Generated by Bract Compiler"));
    assert!(implementation.contains("// Generated by Bract Compiler"));
    
    // Check for common C constructs
    assert!(header.contains("#include") || implementation.contains("#include"));
}

/// Test complete compilation pipeline for a simple program
#[test]
fn test_complete_pipeline_simple() {
    let source = r#"
        fn main() -> i32 {
            return 42;
        }
    "#;
    
    let (header, implementation) = compile_bract_source(source)
        .expect("Compilation should succeed");
    
    validate_c_code(&header, &implementation);
    
    // Verify basic structure
    assert!(implementation.contains("main"));
    assert!(implementation.contains("return"));
    assert!(implementation.contains("42"));
}

/// Test compilation of a program with arithmetic operations
#[test]
fn test_complete_pipeline_arithmetic() {
    let source = r#"
        fn add(a: i32, b: i32) -> i32 {
            return a + b;
        }
        
        fn main() -> i32 {
            let result = add(10, 20);
            return result;
        }
    "#;
    
    let (header, implementation) = compile_bract_source(source)
        .expect("Compilation should succeed");
    
    validate_c_code(&header, &implementation);
    
    // Verify functions are present
    assert!(implementation.contains("add"));
    assert!(implementation.contains("main"));
    
    // Verify arithmetic operation
    assert!(implementation.contains("+") || implementation.contains("add"));
}

/// Test compilation of a program with control flow
#[test]
fn test_complete_pipeline_control_flow() {
    let source = r#"
        fn factorial(n: i32) -> i32 {
            if n <= 1 {
                return 1;
            }
            return n * factorial(n - 1);
        }
        
        fn main() -> i32 {
            return factorial(5);
        }
    "#;
    
    let (header, implementation) = compile_bract_source(source)
        .expect("Compilation should succeed");
    
    validate_c_code(&header, &implementation);
    
    // Verify control flow structures
    assert!(implementation.contains("if") || implementation.contains("factorial"));
    assert!(implementation.contains("main"));
}

/// Test compilation of a program with data structures
#[test]
fn test_complete_pipeline_structs() {
    let source = r#"
        struct Point {
            x: i32,
            y: i32,
        }
        
        fn create_point(x: i32, y: i32) -> Point {
            let p = Point { x: x, y: y };
            return p;
        }
        
        fn main() -> i32 {
            let point = create_point(10, 20);
            return point.x + point.y;
        }
    "#;
    
    let (header, implementation) = compile_bract_source(source)
        .expect("Compilation should succeed");
    
    validate_c_code(&header, &implementation);
    
    // Verify struct definition
    assert!(header.contains("struct Point") || header.contains("Point"));
    assert!(implementation.contains("create_point"));
    assert!(implementation.contains("main"));
}

/// Test compilation with runtime generation
#[test]
fn test_complete_pipeline_with_runtime() {
    let source = r#"
        fn main() -> i32 {
            return 0;
        }
    "#;
    
    let temp_dir = create_temp_dir();
    let temp_path = temp_dir.path();
    
    // Compile the Bract source
    let (header, implementation) = compile_bract_source(source)
        .expect("Compilation should succeed");
    
    // Write the generated files
    write_test_file(temp_path, "test.h", &header);
    write_test_file(temp_path, "test.c", &implementation);
    
    // Generate runtime files
    let mut runtime_gen = RuntimeGenerator::new();
    runtime_gen.write_runtime_files(temp_path)
        .expect("Runtime generation should succeed");
    
    // Verify runtime files exist
    assert!(temp_path.join("bract_runtime.h").exists());
    assert!(temp_path.join("bract_runtime.c").exists());
    
    // Read and validate runtime content
    let runtime_header = std::fs::read_to_string(temp_path.join("bract_runtime.h"))
        .expect("Should be able to read runtime header");
    let runtime_impl = std::fs::read_to_string(temp_path.join("bract_runtime.c"))
        .expect("Should be able to read runtime implementation");
    
    assert!(runtime_header.contains("#ifndef") || runtime_header.contains("#include"));
    assert!(runtime_impl.contains("#include"));
}

/// Test compilation with C compiler if available
#[test]
fn test_complete_pipeline_c_compilation() {
    // Skip this test if no C compiler is available
    if !is_c_compiler_available() {
        println!("Skipping C compilation test - no compiler available");
        return;
    }
    
    let source = r#"
        fn main() -> i32 {
            return 42;
        }
    "#;
    
    let temp_dir = create_temp_dir();
    let temp_path = temp_dir.path();
    
    // Compile the Bract source
    let (header, implementation) = compile_bract_source(source)
        .expect("Compilation should succeed");
    
    // Write the generated files
    write_test_file(temp_path, "test.h", &header);
    let c_file = write_test_file(temp_path, "test.c", &implementation);
    
    // Generate runtime files
    let mut runtime_gen = RuntimeGenerator::new();
    runtime_gen.write_runtime_files(temp_path)
        .expect("Runtime generation should succeed");
    
    let runtime_c = temp_path.join("bract_runtime.c");
    
    // Try to compile with GCC
    let output = Command::new("gcc")
        .arg("-c")
        .arg(&c_file)
        .arg(&runtime_c)
        .arg("-o")
        .arg(temp_path.join("test.o"))
        .output();
    
    match output {
        Ok(result) => {
            if !result.status.success() {
                let stderr = String::from_utf8_lossy(&result.stderr);
                panic!("C compilation failed: {}", stderr);
            }
            
            // Verify object file was created
            assert!(temp_path.join("test.o").exists());
        }
        Err(e) => {
            println!("C compilation test skipped: {}", e);
        }
    }
}

/// Test error handling in the complete pipeline
#[test]
fn test_complete_pipeline_error_handling() {
    let invalid_sources = vec![
        // Syntax error
        "fn main() -> i32 { return; }",
        
        // Type error (if semantic analysis catches it)
        "fn main() -> i32 { return \"string\"; }",
        
        // Undefined function
        "fn main() -> i32 { return undefined_function(); }",
    ];
    
    for source in invalid_sources {
        let result = compile_bract_source(source);
        
        // Should either fail compilation or produce valid C code
        match result {
            Ok((header, implementation)) => {
                // If it succeeds, the generated code should still be valid
                validate_c_code(&header, &implementation);
            }
            Err(_) => {
                // Failing is also acceptable for invalid input
            }
        }
    }
}

/// Test performance of complete pipeline
#[test]
fn test_complete_pipeline_performance() {
    use std::time::Instant;
    
    let source = format!(
        "fn main() -> i32 {{\n{}\n    return 0;\n}}",
        (0..100).map(|i| format!("    let var_{} = {} + {};", i, i, i+1))
                .collect::<Vec<_>>()
                .join("\n")
    );
    
    let start = Instant::now();
    let result = compile_bract_source(&source);
    let elapsed = start.elapsed();
    
    println!("Complete pipeline took: {:?}", elapsed);
    
    // Should compile successfully
    assert!(result.is_ok(), "Performance test should compile successfully");
    
    // Performance assertion: complete pipeline should be fast
    assert!(elapsed.as_millis() < 500, "Complete pipeline too slow: {:?}", elapsed);
}

/// Test compilation of multiple modules (if supported)
#[test]
fn test_complete_pipeline_multiple_modules() {
    let source = r#"
        mod math {
            fn square(x: i32) -> i32 {
                return x * x;
            }
        }
        
        fn main() -> i32 {
            return math::square(5);
        }
    "#;
    
    let result = compile_bract_source(source);
    
    // This might not be fully implemented yet, so we allow it to fail
    match result {
        Ok((header, implementation)) => {
            validate_c_code(&header, &implementation);
            assert!(implementation.contains("square"));
            assert!(implementation.contains("main"));
        }
        Err(_) => {
            // Modules might not be fully implemented yet
            println!("Multiple modules not yet supported - skipping test");
        }
    }
}

/// Test memory safety and resource cleanup in generated code
#[test]
fn test_complete_pipeline_memory_safety() {
    let source = r#"
        fn main() -> i32 {
            let x = 42;
            let y = x;
            return y;
        }
    "#;
    
    let (header, implementation) = compile_bract_source(source)
        .expect("Compilation should succeed");
    
    validate_c_code(&header, &implementation);
    
    // Check that generated code doesn't have obvious memory issues
    // (This is basic - real memory safety would need more sophisticated analysis)
    assert!(!implementation.contains("malloc") || implementation.contains("free"));
    assert!(!implementation.contains("alloc") || implementation.contains("dealloc"));
}

/// Helper function to check if a C compiler is available
fn is_c_compiler_available() -> bool {
    Command::new("gcc")
        .arg("--version")
        .output()
        .map(|output| output.status.success())
        .unwrap_or(false)
}

/// Test real-world example programs
#[test]
fn test_real_world_examples() {
    let examples = vec![
        // Fibonacci sequence
        r#"
            fn fibonacci(n: i32) -> i32 {
                if n <= 1 {
                    return n;
                }
                return fibonacci(n - 1) + fibonacci(n - 2);
            }
            
            fn main() -> i32 {
                return fibonacci(10);
            }
        "#,
        
        // Simple calculator
        r#"
            fn add(a: i32, b: i32) -> i32 { return a + b; }
            fn subtract(a: i32, b: i32) -> i32 { return a - b; }
            fn multiply(a: i32, b: i32) -> i32 { return a * b; }
            fn divide(a: i32, b: i32) -> i32 { return a / b; }
            
            fn main() -> i32 {
                let result = add(multiply(5, 3), divide(10, 2));
                return result;
            }
        "#,
        
        // Data processing
        r#"
            struct Data {
                value: i32,
                count: i32,
            }
            
            fn process_data(data: Data) -> i32 {
                return data.value * data.count;
            }
            
            fn main() -> i32 {
                let data = Data { value: 10, count: 5 };
                return process_data(data);
            }
        "#,
    ];
    
    for (i, source) in examples.iter().enumerate() {
        let result = compile_bract_source(source);
        assert!(result.is_ok(), "Example {} should compile successfully", i);
        
        let (header, implementation) = result.unwrap();
        validate_c_code(&header, &implementation);
        assert!(implementation.contains("main"), "Example {} should have main function", i);
    }
} 
