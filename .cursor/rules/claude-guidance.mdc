---
alwaysApply: true
---
# CLAUDE.md - AI Development Guidance ü§ñ

**READ THIS FIRST** - Guidelines for AI assistance on the Prism programming language project

## **PROJECT CONTEXT**

**What we're building:** Prism - a blazingly fast, memory-safe systems programming language
**Goals:** 
- Compile to native machine code ‚ö°
- Memory safety without GC
- Readable syntax 
- Modern features (pattern matching, type inference)
- Excellent tooling

**Current Phase:** [UPDATE THIS AS WE PROGRESS]
- [x] Phase 1: Language Design & Specification
- [x] Phase 2: Lexer/Tokenizer  
- [x] Phase 3: Parser & AST
- [x] Phase 4: Semantic Analysis
- [1/2] Phase 5: Code Generation
- [ ] Phase 6: Tooling (VS Code, LSP)
- [ ] Phase 7: Standard Library & Polish

## **CODE QUALITY REQUIREMENTS**

### **Always Include:**
- ‚úÖ **Comprehensive error handling** - never use `.unwrap()` in production code
- ‚úÖ **Detailed comments** explaining complex algorithms  
- ‚úÖ **Unit tests** for every major function/struct
- ‚úÖ **Performance considerations** - this is a compiler, speed matters
- ‚úÖ **Memory safety** - use Rust idioms properly
- ‚úÖ **Position tracking** for error reporting (line/column numbers)

### **Never Do:**
- ‚ùå **Placeholder code** - always provide complete implementations
- ‚ùå **Unsafe code** without detailed justification
- ‚ùå **Panics in production** - handle errors gracefully
- ‚ùå **Inefficient algorithms** - we're optimizing for speed
- ‚ùå **Magic numbers** - use named constants
- ‚ùå **Poor error messages** - users deserve helpful diagnostics

## **ARCHITECTURE DECISIONS**

### **Language Design:**
- **Syntax:** Clean, readable, not cryptic
- **Types:** Static typing with inference
- **Memory:** Ownership model (Rust-like) or reference counting
- **Compilation:** Direct to machine code (via LLVM later)
- **Initial target:** Transpile to C for bootstrapping

### **Compiler Structure:**
```
Source Code ‚Üí Lexer ‚Üí Parser ‚Üí Semantic Analysis ‚Üí Code Gen ‚Üí Native Binary
```

### **File Organization:**
```
src/
‚îú‚îÄ‚îÄ main.rs           # CLI driver
‚îú‚îÄ‚îÄ lexer.rs          # Tokenization
‚îú‚îÄ‚îÄ parser.rs         # AST generation  
‚îú‚îÄ‚îÄ ast.rs            # AST node definitions
‚îú‚îÄ‚îÄ semantic/         # Type checking, symbol tables
‚îú‚îÄ‚îÄ codegen/          # Code generation
‚îî‚îÄ‚îÄ lsp/              # Language Server Protocol
```

## **DEVELOPMENT PRIORITIES**

1. **Correctness** - It must work correctly first
2. **Performance** - Compilation speed is crucial  
3. **Error Messages** - Help users fix problems quickly
4. **Maintainability** - Code should be clean and documented
5. **Testing** - Comprehensive test coverage

## **LANGUAGE FEATURES TO IMPLEMENT**

### **Core Features (Phase 1-5):**
- Variables, functions, control flow
- Static typing with inference
- Structs, enums, pattern matching
- Memory management (ownership/borrowing)
- Module system
- Error handling

### **Advanced Features (Later):**
- Generics/templates
- Async/await
- Traits/interfaces  
- Package manager
- Cross-compilation

## **REQUEST GUIDELINES**

### **Good Request Format:**
```
Context: Working on [specific component]
Goal: [what you want to achieve]
Requirements: [specific requirements]
Output: [file structure, tests, documentation needed]
```

### **When Asking for Code:**
- Specify exact file names and locations
- Request complete implementations, not snippets
- Ask for tests and documentation together
- Include error handling requirements
- Specify performance considerations

### **Code Review Checklist:**
- [ ] All errors handled properly
- [ ] Performance optimized
- [ ] Comprehensive tests included
- [ ] Clear documentation/comments
- [ ] Follows Rust best practices
- [ ] Integrates with existing codebase

## **TESTING STRATEGY**

- **Unit tests** for individual functions
- **Integration tests** for component interaction
- **End-to-end tests** with real Prism programs
- **Performance benchmarks** for compilation speed
- **Error handling tests** for edge cases

## **COMMON PITFALLS TO AVOID**

1. **Over-engineering** - Start simple, add complexity gradually
2. **Premature optimization** - Profile before optimizing
3. **Inconsistent error handling** - Use Result<T,E> consistently
4. **Poor separation of concerns** - Keep modules focused
5. **Inadequate testing** - Test both happy path and edge cases


## **SUCCESS METRICS**

- **Compilation speed** - Large projects compile in seconds
- **Memory usage** - Efficient compiler memory usage
- **Error quality** - Clear, actionable error messages  
- **Developer experience** - Smooth tooling and debugging
- **Performance** - Generated code runs fast

---

**Remember:** We're building a production-quality programming language. Every component should be robust, well-tested, and performant. No shortcuts! üöÄ